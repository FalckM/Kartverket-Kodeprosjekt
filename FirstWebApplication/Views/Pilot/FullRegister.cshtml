@model FirstWebApplication.Entities.ObstacleData

@{
    ViewData["Title"] = "Full Registration";
}

<!-- Leaflet Draw CSS for drawing tools -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />

<style>
    #map {
        height: calc(100vh - 120px);
        width: 100%;
        position: relative;
        z-index: 0;
    }
    
    .registration-form {
        position: absolute;
        top: 20px;
        right: 20px;
        width: 400px;
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        z-index: 1000;
        max-height: calc(100vh - 160px);
        overflow-y: auto;
    }

    .form-group {
        margin-bottom: 15px;
    }

    .form-group label {
        display: block;
        margin-bottom: 5px;
        font-weight: 600;
        color: #333;
    }

    .form-control {
        width: 100%;
        padding: 8px 12px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 14px;
    }

    .form-control:focus {
        outline: none;
        border-color: #4F46E5;
    }

    .btn {
        padding: 10px 20px;
        border: none;
        border-radius: 4px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.15s;
    }

    .btn-primary {
        background: #4F46E5;
        color: white;
    }

    .btn-primary:hover {
        background: #4338CA;
    }

    .btn-secondary {
        background: #6B7280;
        color: white;
        margin-top: 10px;
    }

    .btn-secondary:hover {
        background: #4B5563;
    }

    .alert {
        padding: 12px;
        border-radius: 4px;
        margin-bottom: 15px;
    }

    .alert-info {
        background: #DBEAFE;
        color: #1E40AF;
        border: 1px solid #93C5FD;
    }

    .alert-danger {
        background: #FEE2E2;
        color: #991B1B;
        border: 1px solid #FECACA;
    }

    .text-validation-error {
        color: #DC2626;
        font-size: 12px;
        margin-top: 4px;
        display: block;
    }

    /* Loading indicator */
    .loading-overlay {
        position: absolute;
        top: 80px;
        left: 20px;
        background: white;
        padding: 12px 20px;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        z-index: 999;
        font-size: 14px;
        color: #6B7280;
    }

    .loading-overlay.hidden {
        display: none;
    }
</style>

<!-- Map Container -->
<div id="map"></div>

<!-- Loading indicator -->
<div id="loading-obstacles" class="loading-overlay">
    <span>üìç Loading existing obstacles...</span>
</div>

<!-- Registration Form (Sidebar) -->
<div class="registration-form">
    <h2 style="margin-top: 0; color: #1F2937; font-size: 24px;">Full Registration</h2>
    <p style="color: #6B7280; font-size: 14px;">Mark the obstacle on the map and provide complete details</p>

    <div class="alert alert-info">
        <strong>How to register:</strong>
        <ul style="margin: 8px 0 0 0; padding-left: 20px; font-size: 13px;">
            <li>üî¥ Red markers = Existing obstacles (click to view)</li>
            <li>üü¢ Use draw tools to add your new obstacle</li>
            <li>üìù Fill in all required details below</li>
            <li>‚úÖ Click Submit to complete registration</li>
        </ul>
    </div>

    <form asp-action="FullRegister" method="post" id="registrationForm">
        <!-- Hidden field for geometry -->
        <input type="hidden" asp-for="ObstacleGeometry" id="obstacleGeometry" />

        <!-- Obstacle Name -->
        <div class="form-group">
            <label asp-for="ObstacleName">Obstacle Name *</label>
            <input asp-for="ObstacleName" class="form-control" placeholder="e.g., Radio Tower, Power Line" />
            <span asp-validation-for="ObstacleName" class="text-validation-error"></span>
        </div>

        <!-- Obstacle Type -->
        <div class="form-group">
            <label asp-for="ObstacleType">Obstacle Type *</label>
            <select asp-for="ObstacleType" class="form-control">
                <option value="">-- Select Type --</option>
                <option value="Mast">Mast (Radio/TV Tower)</option>
                <option value="Str√∏mledning">Str√∏mledning (Power Line)</option>
                <option value="Vindturbin">Vindturbin (Wind Turbine)</option>
                <option value="Bygning">Bygning (Building)</option>
                <option value="Kirket√•rn">Kirket√•rn (Church Spire)</option>
                <option value="Kran">Kran (Crane)</option>
                <option value="Skorstein">Skorstein (Smoke Stack)</option>
                <option value="Monument">Monument</option>
                <option value="Antenne">Antenne (Mobile/Communication)</option>
                <option value="Annet">Annet (Other)</option>
            </select>
            <span asp-validation-for="ObstacleType" class="text-validation-error"></span>
        </div>

        <!-- Height -->
        <div class="form-group">
            <label asp-for="ObstacleHeight">Height (meters) *</label>
            <input asp-for="ObstacleHeight" type="number" step="0.1" class="form-control" placeholder="0" />
            <span asp-validation-for="ObstacleHeight" class="text-validation-error"></span>
        </div>

        <!-- Description -->
        <div class="form-group">
            <label asp-for="ObstacleDescription">Description *</label>
            <textarea asp-for="ObstacleDescription" class="form-control" rows="4" placeholder="Provide detailed information about the obstacle..."></textarea>
            <span asp-validation-for="ObstacleDescription" class="text-validation-error"></span>
        </div>

        <!-- Submit Button -->
        <button type="submit" class="btn btn-primary" style="width: 100%;">Complete Registration</button>
        
        <!-- Back Link -->
        <a asp-action="RegisterType" class="btn btn-secondary" style="width: 100%; display: block; text-align: center; text-decoration: none;">
            ‚Üê Back to Registration Options
        </a>
    </form>
</div>

@section Scripts {
    <!-- Leaflet Draw JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
    
    <script>
        // Initialize map centered on Norway
        const map = L.map('map').setView([60.4720, 8.4689], 6);

        // Add OpenStreetMap tiles
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap contributors',
            maxZoom: 19
        }).addTo(map);

        // Create a feature group to store drawn items (NEW obstacles only)
        const drawnItems = new L.FeatureGroup();
        map.addLayer(drawnItems);

        // Create a separate layer for EXISTING obstacles (read-only)
        const existingObstaclesLayer = new L.LayerGroup();
        map.addLayer(existingObstaclesLayer);

        // Initialize the draw control
        const drawControl = new L.Control.Draw({
            position: 'topleft',
            draw: {
                polygon: {
                    allowIntersection: false,
                    showArea: true,
                    shapeOptions: {
                        color: '#10b981' // Green for new obstacles
                    }
                },
                polyline: {
                    shapeOptions: {
                        color: '#10b981' // Green for new obstacles
                    }
                },
                circle: false,
                circlemarker: false,
                rectangle: {
                    shapeOptions: {
                        color: '#10b981' // Green for new obstacles
                    }
                },
                marker: true
            },
            edit: {
                featureGroup: drawnItems,
                remove: true
            }
        });
        map.addControl(drawControl);

        // ========================================================================
        // LOAD EXISTING OBSTACLES FROM SERVER
        // ========================================================================
        fetch('/Pilot/GetAllObstaclesJson')
            .then(response => response.json())
            .then(obstacles => {
                console.log(`Loaded ${obstacles.length} existing obstacles`);
                
                obstacles.forEach(obstacle => {
                    try {
                        // Parse geometry (can be GeoJSON or WKT)
                        let geometry = null;
                        
                        try {
                            // Try GeoJSON first
                            const geoJSON = JSON.parse(obstacle.geometry);
                            geometry = geoJSON;
                        } catch {
                            // If not GeoJSON, try WKT
                            geometry = parseWKT(obstacle.geometry);
                        }

                        if (geometry) {
                            // Create marker/layer for this obstacle
                            let layer;

                            if (geometry.type === 'Point' || geometry.geometry?.type === 'Point') {
                                const coords = geometry.geometry ? geometry.geometry.coordinates : geometry.coordinates;
                                layer = L.marker([coords[1], coords[0]], {
                                    icon: L.icon({
                                        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
                                        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
                                        iconSize: [25, 41],
                                        iconAnchor: [12, 41],
                                        popupAnchor: [1, -34],
                                        shadowSize: [41, 41]
                                    })
                                });
                            } else if (geometry.type === 'LineString' || geometry.geometry?.type === 'LineString') {
                                const coords = geometry.geometry ? geometry.geometry.coordinates : geometry.coordinates;
                                const latLngs = coords.map(c => [c[1], c[0]]);
                                layer = L.polyline(latLngs, { color: '#ef4444', weight: 3 }); // Red
                            } else if (geometry.type === 'Polygon' || geometry.geometry?.type === 'Polygon') {
                                const coords = geometry.geometry ? geometry.geometry.coordinates[0] : geometry.coordinates[0];
                                const latLngs = coords.map(c => [c[1], c[0]]);
                                layer = L.polygon(latLngs, { color: '#ef4444', weight: 3 }); // Red
                            }

                            if (layer) {
                                // Add popup with obstacle info
                                const statusText = obstacle.isApproved ? '‚úÖ Approved' : 
                                                 obstacle.isRejected ? '‚ùå Rejected' : 
                                                 '‚è≥ Pending';

                                layer.bindPopup(`
                                    <div style="min-width: 200px;">
                                        <strong style="font-size: 16px;">${obstacle.name}</strong><br>
                                        <strong>Type:</strong> ${obstacle.type}<br>
                                        <strong>Height:</strong> ${obstacle.height} m<br>
                                        <strong>Status:</strong> ${statusText}<br>
                                        <br>
                                        <em style="color: #6B7280; font-size: 12px;">ID: #${obstacle.id}</em>
                                    </div>
                                `);

                                // Add to existing obstacles layer (NOT editable)
                                existingObstaclesLayer.addLayer(layer);
                            }
                        }
                    } catch (error) {
                        console.error('Error displaying obstacle:', obstacle.id, error);
                    }
                });

                // Hide loading indicator
                document.getElementById('loading-obstacles').classList.add('hidden');
            })
            .catch(error => {
                console.error('Error loading obstacles:', error);
                document.getElementById('loading-obstacles').innerHTML = '<span style="color: #ef4444;">‚ùå Failed to load obstacles</span>';
            });

        // ========================================================================
        // HANDLE NEW OBSTACLE CREATION (GREEN)
        // ========================================================================
        map.on(L.Draw.Event.CREATED, function (event) {
            const layer = event.layer;
            
            // Remove previous drawings (only allow one NEW obstacle)
            drawnItems.clearLayers();
            
            // Add the new drawing (GREEN)
            drawnItems.addLayer(layer);
            
            // Convert to WKT format and save to hidden field
            const geoJSON = layer.toGeoJSON();
            const wkt = convertGeoJSONToWKT(geoJSON);
            document.getElementById('obstacleGeometry').value = wkt;
            
            console.log('New obstacle geometry saved:', wkt);
        });

        // Handle when user edits their NEW obstacle
        map.on(L.Draw.Event.EDITED, function (event) {
            const layers = event.layers;
            layers.eachLayer(function (layer) {
                const geoJSON = layer.toGeoJSON();
                const wkt = convertGeoJSONToWKT(geoJSON);
                document.getElementById('obstacleGeometry').value = wkt;
            });
        });

        // Handle when user deletes their NEW obstacle
        map.on(L.Draw.Event.DELETED, function (event) {
            document.getElementById('obstacleGeometry').value = '';
        });

        // ========================================================================
        // UTILITY FUNCTIONS
        // ========================================================================

        // Convert GeoJSON to WKT format
        function convertGeoJSONToWKT(geoJSON) {
            const geometry = geoJSON.geometry;
            const type = geometry.type;
            const coordinates = geometry.coordinates;

            if (type === 'Point') {
                return `POINT(${coordinates[0]} ${coordinates[1]})`;
            } else if (type === 'LineString') {
                const coords = coordinates.map(c => `${c[0]} ${c[1]}`).join(', ');
                return `LINESTRING(${coords})`;
            } else if (type === 'Polygon') {
                const coords = coordinates[0].map(c => `${c[0]} ${c[1]}`).join(', ');
                return `POLYGON((${coords}))`;
            }
            return '';
        }

        // Parse WKT to GeoJSON-like structure
        function parseWKT(wkt) {
            if (wkt.startsWith('POINT')) {
                const coords = wkt.match(/POINT\(([-\d.]+) ([-\d.]+)\)/);
                if (coords) {
                    return {
                        type: 'Point',
                        coordinates: [parseFloat(coords[1]), parseFloat(coords[2])]
                    };
                }
            } else if (wkt.startsWith('LINESTRING')) {
                const coordsStr = wkt.match(/LINESTRING\((.*)\)/)[1];
                const coordinates = coordsStr.split(', ').map(coord => {
                    const [lon, lat] = coord.split(' ').map(parseFloat);
                    return [lon, lat];
                });
                return { type: 'LineString', coordinates };
            } else if (wkt.startsWith('POLYGON')) {
                const coordsStr = wkt.match(/POLYGON\(\((.*)\)\)/)[1];
                const coordinates = coordsStr.split(', ').map(coord => {
                    const [lon, lat] = coord.split(' ').map(parseFloat);
                    return [lon, lat];
                });
                return { type: 'Polygon', coordinates: [coordinates] };
            }
            return null;
        }

        // Form validation
        document.getElementById('registrationForm').addEventListener('submit', function(e) {
            const geometry = document.getElementById('obstacleGeometry').value;
            
            if (!geometry) {
                e.preventDefault();
                alert('‚ö†Ô∏è Please mark the obstacle location on the map before submitting!');
                return false;
            }
        });

        // Try to get user's location and center map
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(function(position) {
                const lat = position.coords.latitude;
                const lon = position.coords.longitude;
                map.setView([lat, lon], 13);
            });
        }
    </script>

    @{await Html.RenderPartialAsync("_ValidationScriptsPartial");}
}
